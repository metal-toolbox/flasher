// Code generated by mockery v2.42.1. DO NOT EDIT.

package device

import (
	constants "github.com/bmc-toolbox/bmclib/v2/constants"
	common "github.com/bmc-toolbox/common"

	context "context"

	mock "github.com/stretchr/testify/mock"

	os "os"
)

// MockQueryor is an autogenerated mock type for the Queryor type
type MockQueryor struct {
	mock.Mock
}

type MockQueryor_Expecter struct {
	mock *mock.Mock
}

func (_m *MockQueryor) EXPECT() *MockQueryor_Expecter {
	return &MockQueryor_Expecter{mock: &_m.Mock}
}

// Close provides a mock function with given fields: ctx
func (_m *MockQueryor) Close(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQueryor_Close_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Close'
type MockQueryor_Close_Call struct {
	*mock.Call
}

// Close is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockQueryor_Expecter) Close(ctx interface{}) *MockQueryor_Close_Call {
	return &MockQueryor_Close_Call{Call: _e.mock.On("Close", ctx)}
}

func (_c *MockQueryor_Close_Call) Run(run func(ctx context.Context)) *MockQueryor_Close_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockQueryor_Close_Call) Return(_a0 error) *MockQueryor_Close_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQueryor_Close_Call) RunAndReturn(run func(context.Context) error) *MockQueryor_Close_Call {
	_c.Call.Return(run)
	return _c
}

// FirmwareInstallSteps provides a mock function with given fields: ctx, component
func (_m *MockQueryor) FirmwareInstallSteps(ctx context.Context, component string) ([]constants.FirmwareInstallStep, error) {
	ret := _m.Called(ctx, component)

	if len(ret) == 0 {
		panic("no return value specified for FirmwareInstallSteps")
	}

	var r0 []constants.FirmwareInstallStep
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]constants.FirmwareInstallStep, error)); ok {
		return rf(ctx, component)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []constants.FirmwareInstallStep); ok {
		r0 = rf(ctx, component)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]constants.FirmwareInstallStep)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, component)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQueryor_FirmwareInstallSteps_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirmwareInstallSteps'
type MockQueryor_FirmwareInstallSteps_Call struct {
	*mock.Call
}

// FirmwareInstallSteps is a helper method to define mock.On call
//   - ctx context.Context
//   - component string
func (_e *MockQueryor_Expecter) FirmwareInstallSteps(ctx interface{}, component interface{}) *MockQueryor_FirmwareInstallSteps_Call {
	return &MockQueryor_FirmwareInstallSteps_Call{Call: _e.mock.On("FirmwareInstallSteps", ctx, component)}
}

func (_c *MockQueryor_FirmwareInstallSteps_Call) Run(run func(ctx context.Context, component string)) *MockQueryor_FirmwareInstallSteps_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockQueryor_FirmwareInstallSteps_Call) Return(_a0 []constants.FirmwareInstallStep, _a1 error) *MockQueryor_FirmwareInstallSteps_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQueryor_FirmwareInstallSteps_Call) RunAndReturn(run func(context.Context, string) ([]constants.FirmwareInstallStep, error)) *MockQueryor_FirmwareInstallSteps_Call {
	_c.Call.Return(run)
	return _c
}

// FirmwareInstallUploadAndInitiate provides a mock function with given fields: ctx, component, file
func (_m *MockQueryor) FirmwareInstallUploadAndInitiate(ctx context.Context, component string, file *os.File) (string, error) {
	ret := _m.Called(ctx, component, file)

	if len(ret) == 0 {
		panic("no return value specified for FirmwareInstallUploadAndInitiate")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *os.File) (string, error)); ok {
		return rf(ctx, component, file)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *os.File) string); ok {
		r0 = rf(ctx, component, file)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *os.File) error); ok {
		r1 = rf(ctx, component, file)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQueryor_FirmwareInstallUploadAndInitiate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirmwareInstallUploadAndInitiate'
type MockQueryor_FirmwareInstallUploadAndInitiate_Call struct {
	*mock.Call
}

// FirmwareInstallUploadAndInitiate is a helper method to define mock.On call
//   - ctx context.Context
//   - component string
//   - file *os.File
func (_e *MockQueryor_Expecter) FirmwareInstallUploadAndInitiate(ctx interface{}, component interface{}, file interface{}) *MockQueryor_FirmwareInstallUploadAndInitiate_Call {
	return &MockQueryor_FirmwareInstallUploadAndInitiate_Call{Call: _e.mock.On("FirmwareInstallUploadAndInitiate", ctx, component, file)}
}

func (_c *MockQueryor_FirmwareInstallUploadAndInitiate_Call) Run(run func(ctx context.Context, component string, file *os.File)) *MockQueryor_FirmwareInstallUploadAndInitiate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*os.File))
	})
	return _c
}

func (_c *MockQueryor_FirmwareInstallUploadAndInitiate_Call) Return(taskID string, err error) *MockQueryor_FirmwareInstallUploadAndInitiate_Call {
	_c.Call.Return(taskID, err)
	return _c
}

func (_c *MockQueryor_FirmwareInstallUploadAndInitiate_Call) RunAndReturn(run func(context.Context, string, *os.File) (string, error)) *MockQueryor_FirmwareInstallUploadAndInitiate_Call {
	_c.Call.Return(run)
	return _c
}

// FirmwareInstallUploaded provides a mock function with given fields: ctx, component, uploadVerifyTaskID
func (_m *MockQueryor) FirmwareInstallUploaded(ctx context.Context, component string, uploadVerifyTaskID string) (string, error) {
	ret := _m.Called(ctx, component, uploadVerifyTaskID)

	if len(ret) == 0 {
		panic("no return value specified for FirmwareInstallUploaded")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (string, error)); ok {
		return rf(ctx, component, uploadVerifyTaskID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) string); ok {
		r0 = rf(ctx, component, uploadVerifyTaskID)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, component, uploadVerifyTaskID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQueryor_FirmwareInstallUploaded_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirmwareInstallUploaded'
type MockQueryor_FirmwareInstallUploaded_Call struct {
	*mock.Call
}

// FirmwareInstallUploaded is a helper method to define mock.On call
//   - ctx context.Context
//   - component string
//   - uploadVerifyTaskID string
func (_e *MockQueryor_Expecter) FirmwareInstallUploaded(ctx interface{}, component interface{}, uploadVerifyTaskID interface{}) *MockQueryor_FirmwareInstallUploaded_Call {
	return &MockQueryor_FirmwareInstallUploaded_Call{Call: _e.mock.On("FirmwareInstallUploaded", ctx, component, uploadVerifyTaskID)}
}

func (_c *MockQueryor_FirmwareInstallUploaded_Call) Run(run func(ctx context.Context, component string, uploadVerifyTaskID string)) *MockQueryor_FirmwareInstallUploaded_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockQueryor_FirmwareInstallUploaded_Call) Return(installTaskID string, err error) *MockQueryor_FirmwareInstallUploaded_Call {
	_c.Call.Return(installTaskID, err)
	return _c
}

func (_c *MockQueryor_FirmwareInstallUploaded_Call) RunAndReturn(run func(context.Context, string, string) (string, error)) *MockQueryor_FirmwareInstallUploaded_Call {
	_c.Call.Return(run)
	return _c
}

// FirmwareTaskStatus provides a mock function with given fields: ctx, kind, component, taskID, installVersion
func (_m *MockQueryor) FirmwareTaskStatus(ctx context.Context, kind constants.FirmwareInstallStep, component string, taskID string, installVersion string) (constants.TaskState, string, error) {
	ret := _m.Called(ctx, kind, component, taskID, installVersion)

	if len(ret) == 0 {
		panic("no return value specified for FirmwareTaskStatus")
	}

	var r0 constants.TaskState
	var r1 string
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, constants.FirmwareInstallStep, string, string, string) (constants.TaskState, string, error)); ok {
		return rf(ctx, kind, component, taskID, installVersion)
	}
	if rf, ok := ret.Get(0).(func(context.Context, constants.FirmwareInstallStep, string, string, string) constants.TaskState); ok {
		r0 = rf(ctx, kind, component, taskID, installVersion)
	} else {
		r0 = ret.Get(0).(constants.TaskState)
	}

	if rf, ok := ret.Get(1).(func(context.Context, constants.FirmwareInstallStep, string, string, string) string); ok {
		r1 = rf(ctx, kind, component, taskID, installVersion)
	} else {
		r1 = ret.Get(1).(string)
	}

	if rf, ok := ret.Get(2).(func(context.Context, constants.FirmwareInstallStep, string, string, string) error); ok {
		r2 = rf(ctx, kind, component, taskID, installVersion)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockQueryor_FirmwareTaskStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirmwareTaskStatus'
type MockQueryor_FirmwareTaskStatus_Call struct {
	*mock.Call
}

// FirmwareTaskStatus is a helper method to define mock.On call
//   - ctx context.Context
//   - kind constants.FirmwareInstallStep
//   - component string
//   - taskID string
//   - installVersion string
func (_e *MockQueryor_Expecter) FirmwareTaskStatus(ctx interface{}, kind interface{}, component interface{}, taskID interface{}, installVersion interface{}) *MockQueryor_FirmwareTaskStatus_Call {
	return &MockQueryor_FirmwareTaskStatus_Call{Call: _e.mock.On("FirmwareTaskStatus", ctx, kind, component, taskID, installVersion)}
}

func (_c *MockQueryor_FirmwareTaskStatus_Call) Run(run func(ctx context.Context, kind constants.FirmwareInstallStep, component string, taskID string, installVersion string)) *MockQueryor_FirmwareTaskStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(constants.FirmwareInstallStep), args[2].(string), args[3].(string), args[4].(string))
	})
	return _c
}

func (_c *MockQueryor_FirmwareTaskStatus_Call) Return(state constants.TaskState, status string, err error) *MockQueryor_FirmwareTaskStatus_Call {
	_c.Call.Return(state, status, err)
	return _c
}

func (_c *MockQueryor_FirmwareTaskStatus_Call) RunAndReturn(run func(context.Context, constants.FirmwareInstallStep, string, string, string) (constants.TaskState, string, error)) *MockQueryor_FirmwareTaskStatus_Call {
	_c.Call.Return(run)
	return _c
}

// FirmwareUpload provides a mock function with given fields: ctx, component, reader
func (_m *MockQueryor) FirmwareUpload(ctx context.Context, component string, reader *os.File) (string, error) {
	ret := _m.Called(ctx, component, reader)

	if len(ret) == 0 {
		panic("no return value specified for FirmwareUpload")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *os.File) (string, error)); ok {
		return rf(ctx, component, reader)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *os.File) string); ok {
		r0 = rf(ctx, component, reader)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *os.File) error); ok {
		r1 = rf(ctx, component, reader)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQueryor_FirmwareUpload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FirmwareUpload'
type MockQueryor_FirmwareUpload_Call struct {
	*mock.Call
}

// FirmwareUpload is a helper method to define mock.On call
//   - ctx context.Context
//   - component string
//   - reader *os.File
func (_e *MockQueryor_Expecter) FirmwareUpload(ctx interface{}, component interface{}, reader interface{}) *MockQueryor_FirmwareUpload_Call {
	return &MockQueryor_FirmwareUpload_Call{Call: _e.mock.On("FirmwareUpload", ctx, component, reader)}
}

func (_c *MockQueryor_FirmwareUpload_Call) Run(run func(ctx context.Context, component string, reader *os.File)) *MockQueryor_FirmwareUpload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*os.File))
	})
	return _c
}

func (_c *MockQueryor_FirmwareUpload_Call) Return(uploadVerifyTaskID string, err error) *MockQueryor_FirmwareUpload_Call {
	_c.Call.Return(uploadVerifyTaskID, err)
	return _c
}

func (_c *MockQueryor_FirmwareUpload_Call) RunAndReturn(run func(context.Context, string, *os.File) (string, error)) *MockQueryor_FirmwareUpload_Call {
	_c.Call.Return(run)
	return _c
}

// Inventory provides a mock function with given fields: ctx
func (_m *MockQueryor) Inventory(ctx context.Context) (*common.Device, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Inventory")
	}

	var r0 *common.Device
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*common.Device, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *common.Device); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*common.Device)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQueryor_Inventory_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Inventory'
type MockQueryor_Inventory_Call struct {
	*mock.Call
}

// Inventory is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockQueryor_Expecter) Inventory(ctx interface{}) *MockQueryor_Inventory_Call {
	return &MockQueryor_Inventory_Call{Call: _e.mock.On("Inventory", ctx)}
}

func (_c *MockQueryor_Inventory_Call) Run(run func(ctx context.Context)) *MockQueryor_Inventory_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockQueryor_Inventory_Call) Return(_a0 *common.Device, _a1 error) *MockQueryor_Inventory_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockQueryor_Inventory_Call) RunAndReturn(run func(context.Context) (*common.Device, error)) *MockQueryor_Inventory_Call {
	_c.Call.Return(run)
	return _c
}

// Open provides a mock function with given fields: ctx
func (_m *MockQueryor) Open(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Open")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQueryor_Open_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Open'
type MockQueryor_Open_Call struct {
	*mock.Call
}

// Open is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockQueryor_Expecter) Open(ctx interface{}) *MockQueryor_Open_Call {
	return &MockQueryor_Open_Call{Call: _e.mock.On("Open", ctx)}
}

func (_c *MockQueryor_Open_Call) Run(run func(ctx context.Context)) *MockQueryor_Open_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockQueryor_Open_Call) Return(_a0 error) *MockQueryor_Open_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQueryor_Open_Call) RunAndReturn(run func(context.Context) error) *MockQueryor_Open_Call {
	_c.Call.Return(run)
	return _c
}

// PowerStatus provides a mock function with given fields: ctx
func (_m *MockQueryor) PowerStatus(ctx context.Context) (string, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for PowerStatus")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (string, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockQueryor_PowerStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PowerStatus'
type MockQueryor_PowerStatus_Call struct {
	*mock.Call
}

// PowerStatus is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockQueryor_Expecter) PowerStatus(ctx interface{}) *MockQueryor_PowerStatus_Call {
	return &MockQueryor_PowerStatus_Call{Call: _e.mock.On("PowerStatus", ctx)}
}

func (_c *MockQueryor_PowerStatus_Call) Run(run func(ctx context.Context)) *MockQueryor_PowerStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockQueryor_PowerStatus_Call) Return(status string, err error) *MockQueryor_PowerStatus_Call {
	_c.Call.Return(status, err)
	return _c
}

func (_c *MockQueryor_PowerStatus_Call) RunAndReturn(run func(context.Context) (string, error)) *MockQueryor_PowerStatus_Call {
	_c.Call.Return(run)
	return _c
}

// ReinitializeClient provides a mock function with given fields: ctx
func (_m *MockQueryor) ReinitializeClient(ctx context.Context) {
	_m.Called(ctx)
}

// MockQueryor_ReinitializeClient_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReinitializeClient'
type MockQueryor_ReinitializeClient_Call struct {
	*mock.Call
}

// ReinitializeClient is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockQueryor_Expecter) ReinitializeClient(ctx interface{}) *MockQueryor_ReinitializeClient_Call {
	return &MockQueryor_ReinitializeClient_Call{Call: _e.mock.On("ReinitializeClient", ctx)}
}

func (_c *MockQueryor_ReinitializeClient_Call) Run(run func(ctx context.Context)) *MockQueryor_ReinitializeClient_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockQueryor_ReinitializeClient_Call) Return() *MockQueryor_ReinitializeClient_Call {
	_c.Call.Return()
	return _c
}

func (_c *MockQueryor_ReinitializeClient_Call) RunAndReturn(run func(context.Context)) *MockQueryor_ReinitializeClient_Call {
	_c.Call.Return(run)
	return _c
}

// ResetBMC provides a mock function with given fields: ctx
func (_m *MockQueryor) ResetBMC(ctx context.Context) error {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ResetBMC")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQueryor_ResetBMC_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetBMC'
type MockQueryor_ResetBMC_Call struct {
	*mock.Call
}

// ResetBMC is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockQueryor_Expecter) ResetBMC(ctx interface{}) *MockQueryor_ResetBMC_Call {
	return &MockQueryor_ResetBMC_Call{Call: _e.mock.On("ResetBMC", ctx)}
}

func (_c *MockQueryor_ResetBMC_Call) Run(run func(ctx context.Context)) *MockQueryor_ResetBMC_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockQueryor_ResetBMC_Call) Return(_a0 error) *MockQueryor_ResetBMC_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQueryor_ResetBMC_Call) RunAndReturn(run func(context.Context) error) *MockQueryor_ResetBMC_Call {
	_c.Call.Return(run)
	return _c
}

// SetPowerState provides a mock function with given fields: ctx, state
func (_m *MockQueryor) SetPowerState(ctx context.Context, state string) error {
	ret := _m.Called(ctx, state)

	if len(ret) == 0 {
		panic("no return value specified for SetPowerState")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, state)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockQueryor_SetPowerState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetPowerState'
type MockQueryor_SetPowerState_Call struct {
	*mock.Call
}

// SetPowerState is a helper method to define mock.On call
//   - ctx context.Context
//   - state string
func (_e *MockQueryor_Expecter) SetPowerState(ctx interface{}, state interface{}) *MockQueryor_SetPowerState_Call {
	return &MockQueryor_SetPowerState_Call{Call: _e.mock.On("SetPowerState", ctx, state)}
}

func (_c *MockQueryor_SetPowerState_Call) Run(run func(ctx context.Context, state string)) *MockQueryor_SetPowerState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockQueryor_SetPowerState_Call) Return(_a0 error) *MockQueryor_SetPowerState_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockQueryor_SetPowerState_Call) RunAndReturn(run func(context.Context, string) error) *MockQueryor_SetPowerState_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockQueryor creates a new instance of MockQueryor. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockQueryor(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockQueryor {
	mock := &MockQueryor{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
